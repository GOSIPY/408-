# 408操作系统知识框架
## 操作系统
### 1.计算机系统概述
    1.os特征（其中并发和共享比较重要）
        1.并发
        2.共享：互斥共享；同时访问
        3.虚拟：空分复用；时分复用
        4.异步
    2.os的发展历史
        1.手工阶段：资源利用率低
        2.单道批处理系统：无需人工
        3.多道批处理系统：资源利用率高,但是不提供人机交互的功能
        4.分时操作系统：采用时间片方式，可以人机交互
        5.实时操作系统：及时可靠
        6.网络操作系统：可以共享资源
        7.分布式操作系统：分布,并行
        8.个人操作系统
    3.操作系统提供接口
        1.命令接口：联机控制方式（cmd）；脱机控制方式（日常编程）
        2.程序接口：GUI
    4.CPU状态
        1.分类：核心态，用户态
        2.从用户态转到核心态：中断；异常；访管指令（访管指令运行在用户态）
    5.操作系统内核
        1.时钟管理：计时；进程切换（时间片轮转调度）
        2.中断机制
        3.原语（设备驱动控制，CPU切换）
        4.系统中的数据结构及处理（进程切换；存储器管理；设备管理）
    6.系统调用
        1.设备管理；文件管理；进程控制；进程通信；内存管理
    7.体系结构
        1.大内核体系结构
        2.微内核体系结构
 ### 2.进程管理
    1.进程
        1.进程由PCB和数据段以及程序段组成，其中PCB包含了进程的描述信息，进程控制和管理信息，资源分配清单，处理机相关信息####PCB是进程存在的唯一标志####
        2.动态，并发，独立，异步，结构特征；进程是独立获得资源和独立接受调度的基本单位
        3.状态：运行态；就绪态；阻塞态（等待态）；创建态；结束态；前三种是基本状态。就绪态是等待CPU，阻塞态是等待I/O或者某些资源，创建态是指进程正在被创建：先申请一个PCB，向PCB写信息，分配资源，最后转入就绪态。
    2.进程控制
        1.进程创建：为进程分配一个进程标识号，并申请一个空白PCB，然后为进程分配资源，若资源不足则处于阻塞态，然后初始化PCB，然后若队列能够接纳新进程，则将新进程插入就绪队列。
        2.进程终止
        3.进程的阻塞和唤醒（阻塞为主动行为）
        4.进程切换
 PS：`多个进程可以运行同一个程序,动态性是进程的最重要的特性` <br>
 
    3.进程的通信
        1.共享存储：采用同步互斥工具PV：基于数据结构的共享；基于存储区的共享
        2.消息传递（借助消息缓冲区）--借助发送消息和接受消息的原语：直接通信方式--缓冲队列；间接通信方式--信箱
        3.管道通信（半双工）：管道是固定大小的缓冲区，允许一边写入一边读
    4.线程
        1.线程不拥有系统资源，共享线程资源，状态仍旧分为就绪，运行和阻塞状态，##线程是处理机独立调度的基本单位##  
        2.实现方式：用户级线程；内核级线程
        3.引入目的：增加多道程序的并发度，提高资源利用率和系统吞吐量，增加程序的并发性。
    5.调度
        1.高级调度（作业调度）从外存中调入作业，分配给他们内存，必要资源，建立进程；中级调度（内存调度）堵塞态->挂起态 or 挂起态->堵塞态；进程调度：分配处理机||最基本
        2.调度方式：非剥夺式调度；剥夺式调度
PS：在处理中断过程中；进程在操作系统的内核程序临界区中；其他需要完全屏蔽中断的原子操作中都不可以进行进程的调度于切换<br>

        3.评价指标：CPU利用率；系统吞吐量；周转时间；相应时间
        4.调度算法:先来先服务算法，短作业优先算法（SJF），优先级调度算法（非剥夺和剥夺）[系统进程>用户进程，交互式>非交互式，I/O>计算型]，高响应比优先调度算法，时间片轮转调度算法（分时系统）[时间片长短由系统响应时间、就绪队列中的进程数目和系统的处理能力]，多级反馈队列调度算法
    6.进程同步
        1.临界：临界资源（一次只能为一个进程所用）；临界区（访问临界资源的那段代码称为临界区）---过程 进入-临界-退出-剩余
        2.同步（直接制约关系）：信号量实现同步
```
semaphore S = 0;
P1()
{
	 一些操作代码...；
	x； // 语句x；
	V（S）// 唤醒另外P进程
}
P2
{
	P(S); // 一直堵塞P2进程，等待唤醒
	Y;   // 被唤醒，执行正事
}
```
        3.互斥（间接制约关系）
            1.实现方法
                1.软件
                  *单标志法 违背 空闲让进 原则
                  *双标志先检查法 违背 忙则等待 原则
                  *双标志后检查法 产生饥饿状态
                  *Peterson's Algorithm:flag 解决临界资源的互斥访问；turn 解决饥饿现象
                2.硬件
                  *中断屏蔽方法（关中断，临界区，开中断）--限制了CPU交替执行的能力，用户能力变大，可以控制中断
                  *硬件指令方法
                    1.TestAndSet指令：读出制定标志后设该标志位真，true表示被占用，初值为false，空闲
                    2.Swap指令：交换两个字节内容，设置局部变量Key
                3.信号量实现互斥
                  *整型信号量：存在忙等
                  *记录型信号量
            2.进程互斥：信号量实现
```
TestAndSet代码
boolean TestAndSet(boolean *lock)
{
	boolean old;
	old = *lock;
	*lock = true;
	return old;   // 设置old为true
}
while （TestAndSet(&lock)）；
{
	临界区代码段；//(进入第一件事，设置lock为true),防止他人进入
	lock = false；
	进程其他代码；
}
```
```
Swap代码
Swap(boolean *a, boolean *b)
{
	boolean temp;
	temp = *a;
	*a = *b;
	*b = temp;
}
Main
{
key = true;
while(key!=false)
	Swap(&lock, &key);//只要有其他进程
								//Lock = true
进程临界区代码段；
lock = false；
进程的其他代码段	
}
```
```
整型信号量操作
wait(S)
{
	while(S<=0);
	S--;
}
signal(S)
{
	S++;
}
```
```
记录型信号量操作
typedef struct
{
	int value;
	struct process *L;// 构造等待序列
}semaphore;
void wait(semaphore S)
{
	S.value --;
	if(S.value < 0)
	{
		add this process to S.l;
		block(S.L); // 放弃处理机，插入等待序列
	}
}
void signal (semaphore S)
{
	S.value++;
	if(S.value > 0)
		{
			remove a  process P from S.L;
			// 告诉阻塞进程P，来资源了，可以干活
			wakeup(P);
		}
}
```
```
信号量实现
semaphore S = 1;
P1()
{
	...;
	P(S); // 准备访问临界资源，加锁
	进程P1的临界区；
	V(S); // 访问结束，解锁	
}
P2()
{
	P(S); // 准备访问临界资源，加锁
	进程P2的临界区；
	V(S);  // 访问结束，解锁 
}
```
        4.经典同步问题(统一把P理解为消耗，V理解为释放)
          1.生产者-消费者问题
          2.写着读者问题
          3.哲学家进餐问题
          4.吸烟者问题
  
            
        
        
    
        

，进程管理，内存管理，文件管理，IO外设管理。
